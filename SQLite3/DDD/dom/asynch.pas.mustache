{{#soa}}
/// asynch version of {{#services}}{{interfaceName}} {{/services}}
unit {{filename}};

{
  WARNING:
    This unit has been generated by {{exeName}}.
    Any manual modification of this file may be lost after regeneration.

  Defines asynchronous (non-blocking) types for the following services:
{{#services}}
  - {{interfaceName}} as non-blocking {{interfaceName}}Asynch,
    associated with blocking T{{uri}}Synch / {{interfaceName}}Synch
{{/services}}

  Corresponding to {{projectname}} version {{exeVersion}}.
  Generated by {{User}} at {{time}}.

}
{{<callparam}}const call: {{calltype}}{{/callparam}}
interface
{{<asynchparam}}{{#asynchkey}}const {{.}}: {{asynchkeytype}}{{/asynchkey}}{{/asynchparam}}
uses
  SysUtils,
  SynCommons,
  SynLog,
  mORMot,
  {{#units}}
  {{.}},
  {{/units}}
  mORMotDDD;
{{<methodasynch}}{{methodName}}({{>asynchparam}}{{#args}}{{#dirInput}};
      {{dirName}} {{argName}}: {{typeSource}}{{/dirInput}}{{/args}};
      {{>callparam}}){{#args}}{{#dirResult}}: {{typeSource}}{{/dirResult}}{{/args}};{{/methodasynch}}
{{<methodack}}{{methodName}}({{>callparam}}; {{#args}}{{^dirResult}}{{#dirOutput}}
      const {{argName}}: {{typeSource}};{{/dirOutput}}{{/dirResult}}{{/args}}{{#args}}{{#dirResult}}
      const res: {{typeSource}}{{/dirResult}}{{/args}});{{/methodack}}
{{<methodsynch}}{{methodName}}({{>asynchparam}}{{#args}}{{^dirResult}};
      {{dirName}} {{argName}}: {{typeSource}}{{/dirResult}}{{/args}}){{#args}}{{#dirResult}}: {{typeSource}}{{/dirResult}}{{/args}};{{/methodsynch}}
{{#services}}
{ -------- asynchronous version of {{interfaceName}} }

type
  /// the {{interfaceName}}Asynch progress callback definition
  // - a single callback, after subscription via Subscribe, would receive the
  // acknowledgements of all {{interfaceName}}Asynch methods
  // - some commands may take a lot of time, so this asynchronous mechanism
  // would increase the system reactivity
  // - naming is following the {{interfaceName}} method names
  // - call: {{calltype}} is the opaque value supplied at command invoke
  {{interfaceName}}AsynchAck = interface(IInvokable)
    ['{{newguid .}}']
    {{#methods}}
    {{^isInherited}}
    procedure {{>methodack}}
    {{/isInherited}}
    {{/methods}}
  end;

  /// high-level asynchronous (non blocking) implementation of {{interfaceName}}
  // - all the methods match the latest inheritance level of synchronous
  // (blocking) {{interfaceName}} - it won't implement the parents methods,
  // since it would allow to work on a dual phase Select/Command with no
  // prior Select (multiple inheritance of interfaces may have helped a lot, but
  // but they are not allowed yet){{#asynchkey}} using {{.}} : {{asynchkeytype}}
  // to redirect the {{interfaceName}}Asynch call to the corresponding {{interfaceName}}
{{/asynchkey}}  // - call: {{calltype}} is an opaque value, which would identify the command
  // when it is acknowledged by {{interfaceName}}AsynchAck
  {{interfaceName}}Asynch = interface(ICQRSService)
    ['{{newguid .}}']
    /// this method is expected to be called once at the beginning of the
    // process, to receive all asynchronous acknowledgements of the other methods
    function Subscribe(const OnAck: {{interfaceName}}AsynchAck): TCQRSResult;
    // all methods below map {{interfaceName}} methods, and their input parameters
    {{#methods}}
    {{^isInherited}}
    {{verb}} {{>methodasynch}}
    {{/isInherited}}
    {{/methods}}
  end;

  /// settings associated to {{interfaceName}}Asynch timeouts
  T{{uri}}Delays = class(TSynPersistent)
  protected
    {{#methods}}
    {{^isInherited}}
    f{{methodName}}: integer;
    {{/isInherited}}
    {{/methods}}
  public
    /// would set all delays to their default values
    constructor Create; override;
  published
    {{#methods}}
    {{^isInherited}}
    property {{methodName}}: integer read f{{methodName}} write f{{methodName}};
    {{/isInherited}}
    {{/methods}}
  end;

  /// waiting semaphore associated to {{interfaceName}}Asynch
  // - used internally by T{{uri}}AsynchAck
  T{{uri}}AsynchCall = class(TBlockingProcessPoolItem)
  protected
    procedure ResetInternal; override; // set Params to 0
  public
{{#asynchkey}}
    // additional parameters, copied from {{interfaceName}}AsynchAck
    Params: record
      {{.}}: {{asynchkeytype}};{{/asynchkey}}
      Res: TCQRSResult;{{#methods}}{{^isInherited}}{{#args}}{{#dirOutput}}{{^dirResult}}
      {{argName}}{{methodIndex}}: {{typeSource}};{{/dirResult}}{{/dirOutput}}{{/args}}{{/isInherited}}{{/methods}}
    end;
  end;

  /// propagate acknowledgements for {{interfaceName}}Asynch
  // - {{interfaceName}}AsynchAck acknowledgements would be propagated using the
  // associated {{calltype}}, to release the wait of the main {{interfaceName}}
  // blocking process
  // - would allow to run {{interfaceName}} blocking methods over a supplied
  // {{interfaceName}}Asynch isntance
  T{{uri}}AsynchAck = class(TCQRSServiceAsynchAck, {{interfaceName}}AsynchAck)
  protected
    function Notify({{>callparam}}; const method: RawUTF8; res: TCQRSResult): boolean; overload;
    function Notify({{>callparam}}; const method: RawUTF8; res: TCQRSResult;
      out process: T{{uri}}AsynchCall): boolean; overload;
    // {{interfaceName}}AsynchAck methods
    // would propagate the acknowledgement, and copy any additional parameter
    // to T{{uri}}AsynchCall.Params
    {{#methods}}
    {{^isInherited}}
    procedure {{>methodack}}
    {{/isInherited}}
    {{/methods}}
  public
    constructor Create(aLog: TSynLogClass);
    /// returns a blocking process from the internal semaphore pool
    function NewAsynchCall: T{{uri}}AsynchCall;
  end;

  /// shared synchronous (blocking) interface of {{interfaceName}}Asynch
{{#asynchkey}}
  // - every method expects a {{.}}: {{asynchkeytype}} first input
  // parameter, in addition to the regular {{interfaceName}} parameters
{{/asynchkey}}
  {{interfaceName}}Synch = interface(IInvokable)
    ['{{newguid .}}']
    {{#methods}}
    {{^isInherited}}
    {{verb}} {{>methodsynch}}
    {{/isInherited}}
    {{/methods}}
  end;

  /// implements {{interfaceName}}Synch over a {{interfaceName}}Asynch instance
  // - it will use a shared T{{uri}}AsynchAck callback to wait for each
  // command to be finished, and emulate synchronous (non-blocking) execution
  // - you may use this class e.g. at API level, over a blocking REST server,
  // and communicate with the Domain event-driven services via asynchronous calls
  T{{uri}}Synch = class(TCQRSServiceSynch, {{interfaceName}}Synch)
  protected
    fLog: TSynLogClass;
    fDelays: T{{uri}}Delays;
    fAsynch: {{interfaceName}}Asynch;
    fSharedCallback: T{{uri}}AsynchAck;
    procedure WaitFor(call: T{{uri}}AsynchCall;{{#asynchkey}} const {{.}}: {{asynchkeytype}};{{/asynchkey}}
      delay: integer; const method: RawUTF8; asynch: TCQRSResult);
  public
    /// initialize the blocking instance
    // - would allocate an internal T{{uri}}AsynchAck callback, and
    // execute {{interfaceName}}Asynch.Subscribe
    constructor Create(aDelays: T{{uri}}Delays;
      const aAsynch: {{interfaceName}}Asynch; aLog: TSynLogClass = nil); reintroduce;
    /// access to the asynchronous methods
    property Asynch: {{interfaceName}}Asynch read fAsynch;
    /// associated time out values, in ms
    property Delays: T{{uri}}Delays read fDelays;
  public
    // {{interfaceName}}Synch blocking methods, returning cqrsTimeout if the
    // non-blocking calls did not respond in the expected delay, or the
    // TCQRSResult returned by the associated {{interfaceName}}Asynch method
    {{#methods}}
    {{^isInherited}}
    {{verb}} {{>methodsynch}}
    {{/isInherited}}
    {{/methods}}
  end;
{{#asynchkey}}{{#query}}{{<method}}{{methodName}}({{#args}}{{^dirResult}}
      {{dirName}} {{argName}}: {{typeSource}}{{commaArg}}{{/dirResult}}{{/args}}){{#args}}{{#dirResult}}: {{typeSource}}{{/dirResult}}{{/args}};{{/method}}
   /// implements CQRS two-phase commit over a {{interfaceName}}Asynch instance
   // - first Select phase should have been implemented in {{.}}
   // - expects a f{{asynchkey}}: {{asynchkeytype}} field to be available,
   // so that the proper {{interfaceName}}Synch method would be called
   // - this abstract class should be inherited, and override Set{{uri}}Synch
   T{{uri}}Abstract = class({{.}}, {{interfaceName}})
   protected
     f{{uri}}Synch: {{interfaceName}}Synch;
     function BeginSynch(var aResult: TCQRSResult): boolean;
     // should be overriden, to set f{{uri}}Synch from f{{asynchkey}}
     procedure Set{{uri}}Synch; virtual; abstract;
   public
    // {{interfaceName}} blocking methods
    {{#methods}}
    {{^isInherited}}
    {{verb}} {{>method}}
    {{/isInherited}}
    {{/methods}}
   end;

{{/query}}{{/asynchkey}}

{{/services}}

implementation

{{#services}}

{ -------- asynchronous version of {{interfaceName}} }

{ T{{uri}}Delays }

constructor T{{uri}}Delays.Create;
begin
  inherited;
  {{#methods}}
  {{^isInherited}}
  f{{methodName}} := {{#asynchdelay}}{{.}}{{/asynchdelay}}{{^asynchdelay}}{{defaultdelay}}{{/asynchdelay}};
  {{/isInherited}}
  {{/methods}}
end;


{ T{{uri}}AsynchCall }

procedure T{{uri}}AsynchCall.ResetInternal;
begin
  inherited ResetInternal; // set fEvent := evNone and fCall := 0
  {$HINTS OFF} // avoid hint if Params has no managed type within
  Finalize(Params);
  {$HINTS ON}
  FillCharFast(Params,sizeof(Params),0);
end;


{ T{{uri}}AsynchAck }

constructor T{{uri}}AsynchAck.Create(aLog: TSynLogClass);
begin
  inherited Create;
  fLog := aLog;
  fCalls := TBlockingProcessPool.Create(T{{uri}}AsynchCall);
end;

function T{{uri}}AsynchAck.Notify({{>callparam}};
  const method: RawUTF8; res: TCQRSResult): boolean;
var
  process: T{{uri}}AsynchCall;
begin
  result := Notify(call, method, res, process);
  if result then
    process.NotifyFinished(true);
end;
{{<callfmt}}%(call=%,{{#asynchkey}}%,{{/asynchkey}}%){{/callfmt}}{{<callval}}[method, id, {{#asynchkey}}process.Params.{{.}}, {{/asynchkey}}ToText(res)^], self);{{/callval}}
function T{{uri}}AsynchAck.Notify({{>callparam}};
  const method: RawUTF8; res: TCQRSResult; out process: T{{uri}}AsynchCall): boolean;
var
  id: integer;
begin
  result := false;
  {{#callfunction}}
  if not {{.}}(call, id) then begin
    fLog.Add.Log(sllTrace, 'Notify: invalid %(call=%) received', [method, call], self);
    exit;
  end;
  {{/callfunction}}
  {{^callfunction}}
  id := call;
  {{/callfunction}}
  process := pointer(fCalls.FromCall(id, true));
  if process = nil then begin
    fLog.Add.Log(sllTrace, 'Notify: deprecated {{>callfmt}} received -> skipped',
      {{>callval}}
    exit;
  end;
  fLog.Add.Log(sllTrace, 'Notify: {{>callfmt}} received',
     {{>callval}}
  process.Params.Res := res;
  result := true;
end;

function T{{uri}}AsynchAck.NewAsynchCall: T{{uri}}AsynchCall;
begin
  result := pointer(fCalls.NewProcess(0));
  if result = nil then
    raise {{Exception}}.CreateUTF8('%.NewAsynchCall: NewProcess=nil', [self]);
end;

{{#methods}}
{{^isInherited}}
procedure T{{uri}}AsynchAck.{{>methodack}}
{{#hasOutNotResultParams}}
var
  process: T{{uri}}AsynchCall;
begin
  if Notify(call, '{{methodName}}', res, process) then begin{{#args}}{{#dirOutput}}{{^dirResult}}
    process.Params.{{argName}}{{methodIndex}} := {{argName}};{{/dirResult}}{{/dirOutput}}{{/args}}
    process.NotifyFinished(true);
  end;
{{/hasOutNotResultParams}}
{{^hasOutNotResultParams}}
begin
  Notify(call, '{{methodName}}', res);
{{/hasOutNotResultParams}}
end;

{{/isInherited}}
{{/methods}}

{ T{{uri}}Synch }

constructor T{{uri}}Synch.Create(aDelays: T{{uri}}Delays;
  const aAsynch: {{interfaceName}}Asynch; aLog: TSynLogClass);
var
  res: TCQRSResult;
begin
  if aDelays = nil then
    raise {{exception}}.CreateUTF8('%.Create(aDelays=nil)', [self]);
  if aAsynch = nil then
    raise {{exception}}.CreateUTF8('%.Create(aAsynch=nil)', [self]);
  fDelays := aDelays;
  fAsynch := aAsynch;
  fLog := aLog;
  fSharedCallback := T{{uri}}AsynchAck.Create(fLog);
  inherited Create(fSharedCallback);
  res := fAsynch.Subscribe(fSharedCallback);
  if res <> cqrsSuccess then
    raise EDomPanel.CreateUTF8('%.Create: {{interfaceName}}Asynch.Subscribe=%',
      [self, ToText(res)^]);
end;
{{<callval2}}[method, call.Call, {{#asynchkey}}{{.}}, {{/asynchkey}}asynchtxt^{{/callval2}}
procedure T{{uri}}Synch.WaitFor(call: T{{uri}}AsynchCall;
  {{#asynchkey}}const {{.}}: {{asynchkeytype}}; {{/asynchkey}}delay: integer; const method: RawUTF8;
  asynch: TCQRSResult);
var
  asynchtxt: PShortString;
begin
{{#asynchkey}}
  call.Params.{{.}} := {{.}}; // for Notify
{{/asynchkey}}
  asynchtxt := ToText(asynch);
  if fLog <> nil then
    fLog.Add.Log(sllDebug, 'WaitFor: Asynch.{{>callfmt}}',
      {{>callval2}}], self);
  if asynch <> cqrsSuccess then
    CqrsSetResultMsg(asynch, 'Asynch.{{>callfmt}}: input parameters?',
      {{>callval2}}])
  else if call.WaitFor(delay) = evTimeOut then
    CqrsSetResultMsg(cqrsTimeout, 'Asynch.{{>callfmt}} timeout after %ms',
      {{>callval2}}, delay])
  else
    CqrsSetResult(call.Params.Res);
end;
{{<argvalue}}{{#isEnum}}ToText({{argName}})^{{/isEnum}}{{^isEnum}}{{argName}}{{/isEnum}}{{/argvalue}}
{{#methods}}
{{^isInherited}}
{{verb}} T{{uri}}Synch.{{>methodsynch}}
var
  log: ISynLog;
  call: T{{uri}}AsynchCall;
begin
  if fLog <> nil then
    log := fLog.Enter('{{methodName}}({{#asynchkey}}{{.}}=%{{/asynchkey}}{{#args}}{{#dirInput}}, {{argName}}=%{{/dirInput}}{{/args}})',
      [{{#asynchkey}}{{.}}{{/asynchkey}}{{#args}}{{#dirInput}},{{>argvalue}}{{/dirInput}}{{/args}}], self);
  if BeginMethods(result) then
  try
    call := fSharedCallback.NewAsynchCall;
    try
      result := Asynch.{{methodName}}({{#asynchkey}}{{.}}, {{/asynchkey}}{{#args}}{{#dirInput}}{{argName}}, {{/dirInput}}{{/args}}call.Call);
      WaitFor(call, {{#asynchkey}}{{.}}, {{/asynchkey}}Delays.{{methodName}}, '{{methodName}}', result);
    finally{{#hasOutNotResultParams}}{{#args}}{{#dirOutput}}{{^dirResult}}
      {{argName}} := call.Params.{{argName}}{{methodIndex}};{{/dirResult}}{{/dirOutput}}{{/args}}{{/hasOutNotResultParams}}
      call.Reset;
    end;
  except
    on E: Exception do
      CqrsSetResult(E);
  end;
  if log <> nil then
    log.Log(sllDebug, '{{methodName}}{{#asynchkey}}(%){{/asynchkey}} returned %{{#args}}{{#dirOutput}}{{^dirResult}} {{argName}}=%{{/dirResult}}{{/dirOutput}}{{/args}}',
      [{{#asynchkey}}{{.}}, {{/asynchkey}}ToText(result)^{{#args}}{{#dirOutput}}{{^dirResult}}, {{>argvalue}}{{/dirResult}}{{/dirOutput}}{{/args}}], self);
end;

{{/isInherited}}
{{/methods}}
{{#asynchkey}}{{#query}}
{ T{{uri}}Abstract }

function T{{uri}}Abstract.BeginSynch(var aResult: TCQRSResult): boolean;
begin
  result := false;
  if CqrsBeginMethod(qaCommandOnSelect, aResult) then begin
    Set{{uri}}Synch;
    if f{{uri}}Synch = nil then
      CqrsSetResultMsg(cqrsInternalError, '{{uri}}Synch=nil')
    else
      result := true;
  end;
end;

{{#methods}}
{{^isInherited}}
{{verb}} T{{uri}}Abstract.{{>method}}
begin
  if BeginSynch(result) then
    CqrsSetResult(f{{uri}}Synch.{{methodName}}(
      f{{asynchkey}}{{#args}}{{^dirResult}}, {{argName}}{{/dirResult}}{{/args}}));
end;

{{/isInherited}}
{{/methods}}

{{/query}}{{/asynchkey}}
{{/services}}
initialization
{{#services}}
  TInterfaceFactory.RegisterInterfaces([
    TypeInfo({{interfaceName}}AsynchAck), TypeInfo({{interfaceName}}Asynch)]);
{{/services}}
{{/soa}}
end.
