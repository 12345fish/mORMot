/// remote access to a mORMot server using SmartMobileStudio
// - retrieved from http://{{host}}/{{uri}}
// at {{time}} using "{{templateName}}" template
unit {{fileName}};

{
  WARNING:
    This unit has been generated by a mORMot {{mORMotVersion}} server.
    Any manual modification of this file may be lost after regeneration.

  Synopse mORMot framework. Copyright (C) {{year}} Arnaud Bouchez
    Synopse Informatique - http://synopse.info

  This unit is released under a MPL/GPL/LGPL tri-license,
  and therefore may be freely included in any application.

  This unit would work on Smart Mobile Studio 2.1 and later.
}

interface

uses
  SmartCL.System,
  System.Types,
  SynCrossPlatformSpecific,
  SynCrossPlatformREST;

{{! recursive partials used to write records type definition}}
{{<writerec}}record
{{#fields}}
{{nestedIdentation}}    {{propName}}: {{#typePascal}}{{typePascal}};{{/typePascal}}{{#nestedRecord}}{{>writerec}}{{nestedIdentation}}    end;{{/nestedRecord}}{{#nestedSimpleArray}}array of {{typePascal}};{{/nestedSimpleArray}}{{#nestedRecordArray}}array of {{>writerec}}{{nestedIdentation}}    end;{{/nestedRecordArray}}
{{/fields}}{{/writerec}}
{{#withEnumerates}}
type // define some enumeration types, used below
{{#enumerates}}
  {{name}} = ({{#values}}{{.}}{{^-last}}, {{/-last}}{{/values}});
{{/enumerates}}

{{/withEnumerates}}
{{#withSets}}
type // define some set types, used below
{{#sets}}
  {{name}} = set of({{#values}}{{.}}{{^-last}}, {{/-last}}{{/values}});
{{/sets}}

{{/withSets}}
{{#withRecords}}
type // define some record types, used as properties below
{{#records}}
  {{name}} = {{>writerec}}  end;

{{/records}}
{{/withRecords}}
type{{<methodSignature}}{{methodName}}({{#args}}{{#dirInput}}{{argName}}: {{typePascal}}; {{/dirInput}}{{/args}}
      onSuccess: procedure({{#args}}{{#dirOutput}}{{argName}}: {{typePascal}}{{commaOutResult}}{{/dirOutput}}{{/args}}); onError: TSQLRestEvent);{{/methodSignature}}{{<method}}{{verb}} {{methodName}}({{#args}}{{^dirResult}}{{dirName}} {{argName}}: {{typeDelphi}}{{commaIn}}{{/dirResult}}{{/args}}){{#args}}{{#dirResult}}: {{typeDelphi}}{{/dirResult}}{{/args}};{{/method}}
{{#soa.services}}
  /// service accessible via http://{{host}}/{{root}}/{{uri}}
  // - this service will run in sic{{instanceCreationName}} mode
  {{#isClientDriven}}
  // - you should call explicitly Free to release the server instance
  {{/isClientDriven}}
  TService{{interfaceURI}} = class(TServiceClientAbstract{{#isClientDriven}}ClientDriven{{/isClientDriven}})
  public
    /// will initialize an access to the remote service
    constructor Create(aClient: TSQLRestClientURI); override;
{{#methods}}
    /// asynchronous version of the following method:
    // ! {{>method}}
    procedure {{>methodSignature}}
{{/methods}}
  end;

{{/soa.services}}
{{#orm}}
{{^isInMormotPas}}
  /// map "{{tableName}}" table
  {{className}} = class(TSQLRecord)
  protected
    {{#fields}}
    f{{name}}: {{typePascal}}; 
    {{/fields}}
    // those overriden methods will emulate the needed RTTI
    class function ComputeRTTI: TRTTIPropInfos; override;
    procedure SetProperty(FieldIndex: integer; const Value: variant); override;
    function GetProperty(FieldIndex: integer): variant; override;
  public
    {{#fields}}
    property {{name}}: {{typePascal}} read f{{name}} write f{{name}};
    {{/fields}}
  end;
  
{{/isInMormotPas}}
{{/orm}}

/// return the database Model corresponding to this server
function GetModel: TSQLModel;

{{#port}}
const
  /// the server port, corresponding to http://{{host}}
  SERVER_PORT = {{port}};

{{/port}}

implementation
{{#withRecords}}
{{<setrec}}{{#fields}}
{{#isSimple}}  result.{{fullPropName}} := Value.{{fullPropName}};
{{/isSimple}}{{#nestedRecord}}{{>setrec}}{{/nestedRecord}}{{#fromVariant}}  result.{{fullPropName}} := {{fromVariant}}(Value.{{fullPropName}});
{{/fromVariant}}{{#nestedSimpleArray}}  for var item in Value.{{fullPropName}} do result.{{fullPropName}}.Add(item);
{{/nestedSimpleArray}}{{#nestedRecordArray}}  result.{{fullPropName}}.SetLength(integer(Value.{{fullPropName}}.length));
  for var n := 0 to result.{{fullPropName}}.High do begin
    var source := Value.{{fullPropName}}[n];
    var dest := result.{{fullPropName}}[n];
{{#fields}}
    dest.{{propName}} := {{#fromVariant}}{{fromVariant}}({{/fromVariant}}source.{{propName}}{{#fromVariant}}){{/fromVariant}};
{{/fields}}
  end;
{{/nestedRecordArray}}{{/fields}}{{/setrec}}
{{<getrec}}{{#fields}}
{{#isSimple}}  result.{{fullPropName}} := Value.{{fullPropName}};
{{/isSimple}}{{#nestedRecord}}  result.{{fullPropName}} := TVariant.CreateObject;
{{>getrec}}{{/nestedRecord}}{{#toVariant}}  result.{{fullPropName}} := {{toVariant}}(Value.{{fullPropName}});
{{/toVariant}}{{#nestedSimpleArray}}  result.{{fullPropName}} := variant(Value.{{fullPropName}});
{{/nestedSimpleArray}}{{#nestedRecordArray}}  result.{{fullPropName}} := TVariant.CreateArray;
  for var source in Value.{{fullPropName}} do begin
    var dest := TVariant.CreateObject;
{{#fields}}
    dest.{{propName}} := {{#toVariant}}{{toVariant}}({{/toVariant}}source.{{propName}}{{#toVariant}}){{/toVariant}};
{{/fields}}
    result.{{fullPropName}}.push(dest);
  end;
{{/nestedRecordArray}}{{/fields}}{{/getrec}}
{{#withEnumerates}}
{ Some helpers for enumerates types }

{{#enumerates}}
function Variant2{{name}}(const _variant: variant): {{name}};
begin
  result := {{name}}(VariantToEnum(_variant,[{{#values}}'{{.}}'{{^-last}},{{/-last}}{{/values}}]));
end;

{{/enumerates}}

{{/withEnumerates}}
{ Some helpers for record types:
  due to potential obfuscation of generated JavaScript, we can't assume
  that the JSON used for transmission would match record fields naming }
{{#records}}

function Variant2{{name}}(const Value: variant): {{name}};
begin
{{>setrec}}
end;

function {{name}}2Variant(const Value: {{name}}): variant;
begin
  result := TVariant.CreateObject;
{{>getrec}}
end;
{{/records}}
{{/withRecords}}

{{#orm}}
{{^isInMormotPas}}

{ {{className}} }

class function {{className}}.ComputeRTTI: TRTTIPropInfos;
begin
  result := TRTTIPropInfos.Create(
    [{{#fields}}'{{name}}'{{comma}}{{/fields}}],
    [{{#fields}}{{typekindname}}{{comma}}{{/fields}}]);
end;

procedure {{className}}.SetProperty(FieldIndex: integer; const Value: variant);
begin
  case FieldIndex of
  0: fID := Value;
  {{#fields}}
  {{index}}: f{{name}} := {{#fromVariant}}{{fromVariant}}({{/fromVariant}}Value{{#fromVariant}}){{/fromVariant}};
  {{/fields}}
  end;
end;

function {{className}}.GetProperty(FieldIndex: integer): variant;
begin
  case FieldIndex of
  0: result := fID;
  {{#fields}}
  {{index}}: result := {{#toVariant}}{{toVariant}}({{/toVariant}}f{{name}}{{#toVariant}}){{/toVariant}};
  {{/fields}}
  end;
end;

{{/isInMormotPas}}
{{/orm}}

function GetModel: TSQLModel;
begin
  result := TSQLModel.Create([{{#orm}}{{className}}{{comma}}{{/orm}}],'{{root}}');
end;

{{#soa.services}}

{ TService{{interfaceURI}} }

constructor TService{{interfaceURI}}.Create(aClient: TSQLRestClientURI);
begin
  fServiceName := '{{interfaceURI}}';
  fServiceURI := '{{uri}}';
  fInstanceImplementation := sic{{instanceCreationName}};
  fContractExpected := '{{contractExpected}}';
  inherited Create(aClient);
end;

{{#methods}}
procedure TService{{interfaceURI}}.{{>methodSignature}}
begin 
  fClient.CallRemoteService(self,'{{methodName}}',{{ArgsOutputCount}},
    [{{#args}}{{#dirInput}}{{#toVariant}}{{toVariant}}({{argName}}){{/toVariant}}{{^toVariant}}{{argName}}{{/toVariant}}{{commaInSingle}}{{/dirInput}}{{/args}}],
    lambda (res: array of Variant)
      onSuccess({{#args}}{{#dirOutput}}{{#fromVariant}}{{fromVariant}}({{/fromVariant}}res[{{indexOutResult}}{{#fromVariant}}){{/fromVariant}}{{#commaOutResult}},{{/commaOutResult}}{{/dirOutput}}{{/args}});
    end, onError); 
end;

{{/methods}}
{{/soa.services}}

end.