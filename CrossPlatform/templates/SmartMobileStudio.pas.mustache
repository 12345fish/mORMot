/// this unit has been generated by a tool - do not modify it by hand
// - retrieved from http://{{host}}/{{uri}}
// at {{time}} using "{{templatename}}" template
unit {{filename}};

interface

uses
  SmartCL.System,
  System.Types,
  SynCrossPlatformSpecific,
  SynCrossPlatformREST;

{{! recursive partials used to write records type definition}}
{{<writerec}}record
{{#fields}}
    {{propname}}: {{#typeName}}{{typeName}}{{/typeName}}{{#isRecord}}{{>writerec}}{{/isRecord}}{{#isSimpleArray}}array of {{typeName}}{{/isSimpleArray}}{{#isRecordArray}}[{{>writerec}}{{/isRecordArray}};
{{/fields}}
  end;
{{/writerec}}
{{<setrec}}{{#fields}}
{{#typeName}}  result.{{propname}} := Value.{{propname}};{{/typeName}}{{#isRecord}}  result.{{propname}} := Value.{{propname}}; TO BE COMPLETED{{/isRecord}}{{#isSimpleArray}}  for var item in Value.{{propname}} do result.{{propname}}.Add(item);{{/isSimpleArray}}{{#isRecordArray}}result.{{propname}} := Value.{{propname}}; TO BE COMPLETED{{/isRecordArray}}
{{/fields}}
{{/setrec}}
{{<getrec}}{{#fields}}
{{#typeName}}  result.{{propname}} := Value.{{propname}};{{/typeName}}{{#isRecord}}  result.{{propname}} := Value.{{propname}}; TO BE COMPLETED{{/isRecord}}{{#isSimpleArray}}  result.{{propname}} := variant(Value.{{propname}});{{/isSimpleArray}}{{#isRecordArray}}result.{{propname}} := Value.{{propname}}; TO BE COMPLETED{{/isRecordArray}}
{{/fields}}
{{/getrec}}
{{#withRecords}}
type // define some record types, used as properties below
  {{#records}}
  {{name}} = {{>writerec}} 
  {{/records}}
{{/withRecords}}
type{{<methodSignature}}{{methodName}}({{#args}}{{#dirInput}}{{argName}}: {{typeName}}; {{/dirInput}}{{/args}}
      onSuccess: procedure({{#args}}{{#dirOutput}}{{argName}}: {{typeName}}{{commaOutResult}}{{/dirOutput}}{{/args}}); onError: TSQLRestEvent);{{/methodSignature}}
{{#soa.services}}
  /// service accessible via http://{{host}}/{{root}}/{{uri}}
  TService{{interfaceURI}} = class(TServiceClientAbstract)
  public
{{#methods}}
    procedure {{>methodSignature}}
{{/methods}}
  end;

{{/soa.services}}
  {{#orm}}
  {{^isinmormotpas}}
  /// map "{{tablename}}" table
  {{classname}} = class(TSQLRecord)
  protected
    {{#fields}}
    f{{name}}: {{typerttiname}}; 
    {{/fields}}
    // those overriden methods will emulate the needed RTTI
    class function ComputeRTTI: TRTTIPropInfos; override;
    procedure SetProperty(FieldIndex: integer; const Value: variant); override;
    function GetProperty(FieldIndex: integer): variant; override;
  public
    {{#fields}}
    property {{name}}: {{typerttiname}} read f{{name}} write f{{name}};
    {{/fields}}
  end;
  
  {{/isinmormotpas}}
  {{/orm}}
  
/// return the database Model corresponding to this server
function GetModel: TSQLModel;

{{#port}}
const
  /// the server port, corresponding to http://{{host}}
  SERVER_PORT = {{port}};

{{/port}}

implementation

{{#withRecords}}

{ define some helpers for record types }
{{#records}}

function Variant2{{name}}(const Value: variant): {{name}};
begin
{{>setrec}}
end;

function {{name}}2Variant(const Value: {{name}}): variant;
begin
  result := TVariant.CreateObject;
{{>getrec}}
end;
{{/records}}
{{/withRecords}}

{{#orm}}
{{^isinmormotpas}}

{ {{classname}} }

class function {{classname}}.ComputeRTTI: TRTTIPropInfos;
begin
  result := TRTTIPropInfos.Create(
    [{{#fields}}'{{name}}'{{comma}}{{/fields}}],
    [{{#fields}}{{typekindname}}{{comma}}{{/fields}}]);
end;

procedure {{classname}}.SetProperty(FieldIndex: integer; const Value: variant);
begin
  case FieldIndex of
  0: fID := Value;
  {{#fields}}
  {{index}}: f{{name}} := {{#isrecord}}Variant2{{typerttiname}}({{/isrecord}}Value{{#isrecord}}){{/isrecord}};
  {{/fields}}
  end;
end;

function {{classname}}.GetProperty(FieldIndex: integer): variant;
begin
  case FieldIndex of
  0: result := fID;
  {{#fields}}
  {{index}}: result := {{#isrecord}}{{typerttiname}}2Variant({{/isrecord}}f{{name}}{{#isrecord}}){{/isrecord}};
  {{/fields}}
  end;
end;

{{/isinmormotpas}}
{{/orm}}

function GetModel: TSQLModel;
begin
  result := TSQLModel.Create([{{#orm}}{{classname}}{{comma}}{{/orm}}],'{{root}}');
end;

{{#soa.services}}

{ TService{{interfaceURI}} }

{{#methods}}
procedure TService{{interfaceURI}}.{{>methodSignature}}
begin 
  fClient.CallRemoteService('{{interfaceURI}}','{{methodName}}',{{ArgsOutputCount}},
    [{{#args}}{{#dirInput}}{{#isrecord}}{{typeName}}2Variant({{argName}}){{/isrecord}}{{^isrecord}}{{argName}}{{/isrecord}}{{commaInSingle}}{{/dirInput}}{{/args}}],
    lambda (res: array of Variant)
      onSuccess({{#args}}{{#dirOutput}}{{#isrecord}}Variant2{{typeName}}({{/isrecord}}res[{{indexOutResult}}{{#isrecord}}){{/isrecord}}{{/dirOutput}}{{/args}});
    end, onError); 
end;

{{/methods}}
{{/soa.services}}

end.