/// this unit has been generated by a tool - do not modify it by hand
// - retrieved from http://{{host}}/{{uri}}
// at {{time}} using "{{templateName}}" template
unit {{fileName}};

interface

uses
  SynCrossPlatformSpecific,
  SynCrossPlatformREST;
  
{{! recursive partials used to write records type definition}}
{{<writerec}}record
{{#fields}}
{{nestedIdentation}}    {{propName}}: {{#typeDelphi}}{{typeDelphi}};{{/typeDelphi}}{{#nestedRecord}}{{>writerec}}{{nestedIdentation}}    end;{{/nestedRecord}}{{#nestedSimpleArray}}array of {{typeDelphi}};{{/nestedSimpleArray}}{{#nestedRecordArray}}array of {{>writerec}}{{nestedIdentation}}    end;{{/nestedRecordArray}}
{{/fields}}{{/writerec}}
{{<setrec}}{{#fields}}
{{#typeName}}  result.{{propName}} := Value.{{propName}};{{/typeName}}{{#isRecord}}  result.{{propName}} := Value.{{propName}}; TO BE COMPLETED{{/isRecord}}{{#nestedSimpleArray}}  for var item in Value.{{propName}} do result.{{propName}}.Add(item);{{/nestedSimpleArray}}{{#nestedRecordArray}}result.{{propName}} := Value.{{propName}}; TO BE COMPLETED{{/nestedRecordArray}}
{{/fields}}
{{/setrec}}
{{<getrec}}{{#fields}}
{{#typeName}}  result.{{propName}} := Value.{{propName}};{{/typeName}}{{#isRecord}}  result.{{propName}} := Value.{{propName}}; TO BE COMPLETED{{/isRecord}}{{#nestedSimpleArray}}  for var item in Value.{{propName}} do result.{{propName}}.Add(item);{{/nestedSimpleArray}}{{#nestedRecordArray}}result.{{propName}} := Value.{{propName}}; TO BE COMPLETED{{/nestedRecordArray}}
{{/fields}}
{{/getrec}}
{{#withEnumerates}}
type // define some enumeration types, used below
{{#enumerates}}
  {{name}} = ({{#values}}{{.}}{{^-last}}, {{/-last}}{{/values}});
{{/enumerates}}

{{/withEnumerates}}
{{#withSets}}
type // define some set types, used below
{{#sets}}
  {{name}} = set of({{#values}}{{.}}{{^-last}}, {{/-last}}{{/values}});
{{/sets}}

{{/withSets}}
{{#withRecords}}
type // define some record types, used as properties below
{{#records}}
  {{name}} = {{>writerec}}  end;

{{/records}}
{{/withRecords}}
type
  {{#orm}}
  {{^isInMormotPas}}
  /// map "{{tableName}}" table
  {{className}} = class(TSQLRecord)
  protected
    {{#fields}}
    f{{name}}: {{typeDelphi}}; 
    {{/fields}}
  {{#hasRecords}}
  public
    {{#fields}}
    {{#isrecord}}
    property {{name}}: {{typeDelphi}} read f{{name}} write f{{name}}{{#unique}} stored AS_UNIQUE{{/unique}};
    {{/isrecord}}
    {{/fields}}
  {{/hasRecords}}
  published
    {{#fields}}
    {{^isrecord}}
    property {{name}}: {{typeDelphi}}{{#width}} index {{width}}{{/width}} read f{{name}} write f{{name}}{{#unique}} stored AS_UNIQUE{{/unique}};
    {{/isrecord}}
    {{/fields}}
  end;
  
  {{/isInMormotPas}}
  {{/orm}}
  
/// return the database Model corresponding to this server
function GetModel: TSQLModel;

{{#port}}
const
  /// the server port, corresponding to http://{{host}}
  SERVER_PORT = {{port}};

{{/port}}

implementation


function GetModel: TSQLModel;
begin
  result := TSQLModel.Create([{{#orm}}{{className}}{{comma}}{{/orm}}],'{{root}}');
end;


end.